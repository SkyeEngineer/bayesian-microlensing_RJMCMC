<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>bayesian-microlensing.plotting API documentation</title>
<meta name="description" content="Plot posterior distributions of microlensing events â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bayesian-microlensing.plotting</code></h1>
</header>
<section id="section-intro">
<p>Plot posterior distributions of microlensing events.</p>
<p>Creates "pointilism" plots which show the discrete posterior,
and heatmap plots which show the true posterior.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Plot posterior distributions of microlensing events.

Creates &#34;pointilism&#34; plots which show the discrete posterior,
and heatmap plots which show the true posterior.
&#34;&#34;&#34;

from cProfile import label
import MulensModel as mm

import math
from copy import deepcopy
import sampling
import numpy as np
import matplotlib.pyplot as plt
import scipy
from scipy.stats import chi2
import corner
import light_curve_simulation
import seaborn as sns
import matplotlib.ticker as ticker
import autocorrelation

def flux(m, theta, ts, caustics = None, label = None, color = None, alpha = None, ls = None, lw = None):
    &#34;&#34;&#34;Plot the magnification produced by a microlensing event.

    Args:
        m: [int] Model index.
        theta: [state] Model parameters.
        ts: [list] Range to plot over.
        caustics: [optional, bool] Whether the plot should be of the caustic curves.
    &#34;&#34;&#34;
    if m == 0:
        model = mm.Model(dict(zip([&#39;t_0&#39;, &#39;u_0&#39;, &#39;t_E&#39;], theta.truth[1:])))
    if m == 1:
        model = mm.Model(dict(zip([&#39;t_0&#39;, &#39;u_0&#39;, &#39;t_E&#39;, &#39;q&#39;, &#39;s&#39;, &#39;alpha&#39;], theta.truth[1:])))
    model.set_magnification_methods([ts[0], &#39;point_source&#39;, ts[1]])

    epochs = np.linspace(ts[0], ts[1], 720)

    if caustics is not None:
        if caustics &gt; 0:
            model.plot_trajectory(t_start = ts[0], t_stop = ts[1], color = &#39;black&#39;, linewidth = 1, ls=&#39;-&#39;, alpha = alpha, arrow = False)
        model.plot_caustics(color = color, s = 0.25, marker = &#39;o&#39;, n_points = 25000, label = label)

    else:
        A = (model.magnification(epochs)-1)*theta.truth[0]+1
        plt.plot(epochs, A, color = color, label = label, alpha = alpha, ls = ls, lw = lw)

    return



def fitted_flux(m, theta, data, ts, label = None, color = None, alpha = None, ls = None, lw = None):
    &#34;&#34;&#34;Plot the flux produced by fitted microlensing parameters.

    Args:
        m: [int] Model index.
        theta: [state] Model parameters.
        ts: [list] Range to plot over.
    &#34;&#34;&#34;
    if m == 0:
        model = mm.Model(dict(zip([&#39;t_0&#39;, &#39;u_0&#39;, &#39;t_E&#39;], theta.truth[1:])))
    if m == 1:
        model = mm.Model(dict(zip([&#39;t_0&#39;, &#39;u_0&#39;, &#39;t_E&#39;, &#39;q&#39;, &#39;s&#39;, &#39;alpha&#39;], theta.truth[1:])))
    model.set_magnification_methods([ts[0], &#39;point_source&#39;, ts[1]])

    epochs = np.linspace(ts[0], ts[1], 720)

    a = model.magnification(epochs)
    # Fit proposed flux as least squares solution.
    #F = light_curve_simulation.least_squares_signal(a, data.flux)
    F = (a-1)*theta.truth[0]+1
    plt.plot(epochs, F, color = color, label = label, alpha = alpha, ls = ls, lw = lw)

    return


def style():
    plt.rcParams[&#34;font.family&#34;] = &#34;sans-serif&#34;
    plt.rcParams[&#39;font.size&#39;] = 15 #12
    plt.style.use(&#39;seaborn-bright&#39;)
    plt.rcParams[&#34;legend.edgecolor&#34;] = &#39;0&#39;
    plt.rcParams[&#34;legend.framealpha&#34;] = 1
    plt.rcParams[&#34;legend.title_fontsize&#34;] = 10
    plt.rcParams[&#34;legend.fontsize&#34;] = 9
    plt.rcParams[&#34;grid.linestyle&#34;] = &#39;dashed&#39; 
    plt.rcParams[&#34;grid.alpha&#34;] = 0.25
    plt.rc(&#39;axes.formatter&#39;, useoffset=False)
    return





def broccoli(joint_model_chain, supset_states, subset_states, surrogate_supset_states, surrogate_subset_states, symbols, ranges, curves, event_params = None, name = &#39;&#39;, dpi = 100):
    &#34;&#34;&#34;Plot the joint posterior surface of two models.

    Args:
        supset_model: [model] Larger parameter space model.
        subset_model: [model] Smaller parameter space model.
        joint_model_chain: [chain] Generalised chain with states from both models.
        symbols: [list] Strings to label plots with.
    &#34;&#34;&#34;

    # Fonts/visibility.
    #lr = 45 # label rotation
    n_ticks = 5 # tick labels
    n_m_ticks = 5

    axis_title_size = 16
    axis_tick_size = 10

    # Model sizing.
    N_dim = 6 #supset_model.D
    n_dim = 3 #subset_model.D

    style()
    figure = corner.corner(supset_states.T) # Use corner for layout/sizing.
    figure.subplots_adjust(wspace = 0, hspace = 0)

    # Fonts/visibility.
    # plt.rcParams[&#39;font.size&#39;] = 12
    # plt.rcParams[&#39;axes.titlesize&#39;] = 20
    # plt.rcParams[&#39;axes.labelsize&#39;] = 20

    # Extract axes.
    axes = np.array(figure.axes).reshape((N_dim, N_dim))

    #print(supset_surrogate.samples.numpy())
    single_theta, binary_theta, data = curves

    # Loop diagonal.
    for i in range(N_dim):
        ax = axes[i, i]

        ax.cla()

        nbins = 20

        if i &lt; 3:
            ax.hist(np.concatenate((surrogate_supset_states[i, :], surrogate_subset_states[i, :])), bins = nbins, density = True, color = &#39;tab:orange&#39;, alpha = 1.0, histtype=&#39;step&#39;, range=ranges[i])
            ax.hist(np.concatenate((supset_states[i, :], subset_states[i, :])), bins = nbins, density = True, color = &#39;tab:blue&#39;, alpha = 1.0, histtype=&#39;step&#39;, range=ranges[i])
            ax.axvline(single_theta.scaled[i+1], color=&#39;tab:green&#39;, ls=&#39;-&#39;, lw=1)

        else:
            ax.hist(surrogate_supset_states[i, :], bins = nbins, density = True, color = &#39;tab:orange&#39;, alpha = 1.0, histtype=&#39;step&#39;, range=ranges[i])
            ax.hist(supset_states[i, :], bins = nbins, density = True, color = &#39;tab:blue&#39;, alpha = 1.0, histtype=&#39;step&#39;, range=ranges[i])

        if event_params is not None:             
            ax.axvline(event_params.scaled[i+1], color = &#39;black&#39;, ls = &#39;-&#39;, lw = 2)
            ax.axvline(binary_theta.scaled[i+1], color=&#39;tab:purple&#39;, ls=&#39;-&#39;, lw=1)



        ax.set_xlim(ranges[i])

        ax.tick_params(which=&#39;both&#39;, top=False, direction=&#39;in&#39;)
        ax.minorticks_on()
        ax.yaxis.set_minor_locator(ticker.AutoMinorLocator(n_m_ticks))
        ax.xaxis.set_minor_locator(ticker.AutoMinorLocator(n_m_ticks))
        ax.tick_params(which=&#39;major&#39;, length=8)
        ax.tick_params(which=&#39;minor&#39;, length=4)
        ax.yaxis.set_major_locator(plt.MaxNLocator(n_ticks))
        ax.xaxis.set_major_locator(plt.MaxNLocator(n_ticks))

        if i == 0: # First diagonal tile.
            #ax.set_ylabel(symbols[i], fontsize = axis_title_size)
            #ax.tick_params(axis=&#39;y&#39;,  labelrotation = 45)
            ax.axes.get_xaxis().set_ticklabels([])
            ax.axes.get_yaxis().set_ticklabels([])
            ax.set_title(&#39;(a)&#39;, loc=&#39;left&#39;, fontsize=20)

        elif i == N_dim - 1: # Last diagonal tile.
            ax.set_xlabel(symbols[i], fontsize = axis_title_size)
            ax.axes.get_yaxis().set_ticklabels([])
            ax.tick_params(axis = &#39;x&#39;,  labelrotation = 45, labelsize = axis_tick_size)
            plt.setp(ax.xaxis.get_majorticklabels(), ha=&#34;right&#34;, rotation_mode=&#34;anchor&#34;)

        else:
            ax.axes.get_xaxis().set_ticklabels([])
            ax.axes.get_yaxis().set_ticklabels([])

        ax.axes.get_yaxis().set_ticks([])

        ax.axes.get_yaxis().set_ticklabels([])
        ax.axes.get_yaxis().set_ticks([])
        #ax.axes.get_xaxis().set_ticklabels([])
        #ax.axes.get_xaxis().set_ticks([])






    # Loop lower triangular.
    for yi in range(N_dim):
        for xi in range(yi):
            ax = axes[yi, xi]
            ax.cla()
            
            #if yi&lt;3 and xi&lt;3:
            #    ax.scatter(subset_states[xi, :], subset_states[yi, :], c = &#39;white&#39;, alpha = 0.0, marker = &#34;.&#34;, s = 75, linewidth = 0.0)
            #ax.scatter(supset_states[xi, :], supset_states[yi, :], c = np.linspace(0.0, 1.0, len(supset_states[yi, :])), cmap = plt.get_cmap(&#39;RdBu&#39;), alpha = 0.05, marker = &#34;o&#34;, s = 25, linewidth = 0.0)

            #xlim = ax.get_xlim()
            #ylim = ax.get_ylim()
            
            sns.kdeplot(x=surrogate_supset_states[xi, :], y=surrogate_supset_states[yi, :], ax=ax, levels=[0.393, 0.865, 0.989], color=&#39;tab:orange&#39;, bw_adjust=1.2, clip=[ranges[xi], ranges[yi]])
            sns.kdeplot(x=supset_states[xi, :], y=supset_states[yi, :], ax=ax, levels=[0.393, 0.865, 0.989], color=&#39;tab:blue&#39;, bw_adjust=1.2, clip=[ranges[xi], ranges[yi]])
            

            ax.scatter(event_params.scaled[xi+1], event_params.scaled[yi+1], color = &#39;black&#39;, alpha = 1.0, marker = &#34;D&#34;, s = 50, linewidth = 1, zorder=9)
            #ax.axvline(event_params.scaled[xi], color = &#39;black&#39;, ls = &#39;-&#39;, lw = 2)
            #ax.axhline(event_params.scaled[yi], color = &#39;black&#39;, ls = &#39;-&#39;, lw = 2)
            ax.scatter(binary_theta.scaled[xi+1], binary_theta.scaled[yi+1], color = &#39;tab:purple&#39;, alpha = 1.0, marker = &#34;8&#34;, s = 50, linewidth = 1, zorder=10)
            ax.set_xlim(ranges[xi])
            ax.set_ylim(ranges[yi])


            ax.tick_params(which=&#39;both&#39;, top=True, right=True, direction=&#39;in&#39;)
            ax.minorticks_on()
            ax.tick_params(which=&#39;major&#39;, length=8)
            ax.tick_params(which=&#39;minor&#39;, length=4)
            ax.yaxis.set_minor_locator(ticker.AutoMinorLocator(n_m_ticks))
            ax.xaxis.set_minor_locator(ticker.AutoMinorLocator(n_m_ticks))
            ax.yaxis.set_major_locator(plt.MaxNLocator(n_ticks))
            ax.xaxis.set_major_locator(plt.MaxNLocator(n_ticks))

            if yi == N_dim - 1: # Bottom row.
                ax.set_xlabel(symbols[xi], fontsize = axis_title_size)
                ax.tick_params(axis = &#39;x&#39;,  labelrotation = 45, labelsize = axis_tick_size)
                plt.setp(ax.xaxis.get_majorticklabels(), ha=&#34;right&#34;, rotation_mode=&#34;anchor&#34;)

            else:    
                ax.axes.get_xaxis().set_ticklabels([])

            if xi == 0: # First column.
                ax.set_ylabel(symbols[yi], fontsize = axis_title_size)
                ax.tick_params(axis = &#39;y&#39;,  labelrotation = 45, labelsize = axis_tick_size)
                plt.setp(ax.yaxis.get_majorticklabels(), va=&#34;bottom&#34;, rotation_mode=&#34;anchor&#34;)

            else:    
                ax.axes.get_yaxis().set_ticklabels([])



            # Add upper triangular plots.
            if xi &lt; n_dim and yi &lt; n_dim:
                
                # Acquire axes and plot.
                axs = figure.get_axes()[4].get_gridspec()
                axt = figure.add_subplot(axs[xi, yi])

                #axt.scatter(subset_states[yi, :], subset_states[xi, :], c = np.linspace(0.0, 1.0, len(subset_states[yi, :])), cmap = plt.get_cmap(&#39;RdBu&#39;), alpha = 0.05, marker = &#34;o&#34;, s = 25, linewidth = 0.0)
                
                sns.kdeplot(x=surrogate_subset_states[yi, :], y=surrogate_subset_states[xi, :], ax=axt, levels=[0.393, 0.865, 0.989], color=&#39;tab:orange&#39;, bw_adjust=1.2, clip=[ranges[yi], ranges[xi]])
                sns.kdeplot(x=subset_states[yi, :], y=subset_states[xi, :], ax=axt, levels=[0.393, 0.865, 0.989], color=&#39;tab:blue&#39;, bw_adjust=1.2, clip=[ranges[yi], ranges[xi]])

                axt.scatter(x=single_theta.scaled[yi+1], y=single_theta.scaled[xi+1], color = &#39;tab:green&#39;, alpha = 1.0, marker = &#34;8&#34;, s = 50, linewidth = 1, zorder=9)

                axt.set_xlim(ranges[yi])
                axt.set_ylim(ranges[xi])

                axt.tick_params(which=&#39;both&#39;, top=True, right=True, direction=&#39;in&#39;)
                axt.minorticks_on()
                axt.yaxis.set_minor_locator(ticker.AutoMinorLocator(n_m_ticks))
                axt.xaxis.set_minor_locator(ticker.AutoMinorLocator(n_m_ticks))
                axt.tick_params(which=&#39;major&#39;, length=8)
                axt.tick_params(which=&#39;minor&#39;, length=4)
                axt.yaxis.set_major_locator(plt.MaxNLocator(n_ticks))
                axt.xaxis.set_major_locator(plt.MaxNLocator(n_ticks))

                if yi == n_dim - 1: # Last column.
                    axt.set_ylabel(symbols[xi], fontsize = axis_title_size)
                    axt.yaxis.tick_right()
                    axt.tick_params(which=&#39;both&#39;, bottom=True, left=True, labelsize = axis_tick_size)
                    axt.yaxis.set_label_position(&#34;right&#34;)
                    axt.tick_params(axis = &#39;y&#39;,  labelrotation = 45, labelsize = axis_tick_size)
                    plt.setp(axt.yaxis.get_majorticklabels(), va=&#34;top&#34;, rotation_mode=&#34;anchor&#34;)
                
                else:
                    axt.axes.get_yaxis().set_ticklabels([])
                
                if xi == 0: # First row.
                    axt.set_xlabel(symbols[yi], fontsize = axis_title_size)
                    axt.tick_params(axis = &#39;x&#39;,  labelrotation = 45, labelsize = axis_tick_size)
                    axt.xaxis.tick_top()
                    axt.tick_params(which=&#39;both&#39;, bottom=True, left=True, labelsize = axis_tick_size)
                    axt.xaxis.set_label_position(&#34;top&#34;)
                    plt.setp(axt.xaxis.get_majorticklabels(), ha=&#34;left&#34;, rotation_mode=&#34;anchor&#34;)
                
                else:
                    axt.axes.get_xaxis().set_ticklabels([])



    figure.savefig(&#39;results/&#39; + name + &#39;-broccoli.png&#39;, bbox_inches = &#34;tight&#34;, dpi = dpi, transparent=True)
    figure.clf()

    return</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bayesian-microlensing.plotting.broccoli"><code class="name flex">
<span>def <span class="ident">broccoli</span></span>(<span>joint_model_chain, supset_states, subset_states, surrogate_supset_states, surrogate_subset_states, symbols, ranges, curves, event_params=None, name='', dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the joint posterior surface of two models.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>supset_model</code></strong></dt>
<dd>[model] Larger parameter space model.</dd>
<dt><strong><code>subset_model</code></strong></dt>
<dd>[model] Smaller parameter space model.</dd>
<dt><strong><code>joint_model_chain</code></strong></dt>
<dd>[chain] Generalised chain with states from both models.</dd>
<dt><strong><code>symbols</code></strong></dt>
<dd>[list] Strings to label plots with.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broccoli(joint_model_chain, supset_states, subset_states, surrogate_supset_states, surrogate_subset_states, symbols, ranges, curves, event_params = None, name = &#39;&#39;, dpi = 100):
    &#34;&#34;&#34;Plot the joint posterior surface of two models.

    Args:
        supset_model: [model] Larger parameter space model.
        subset_model: [model] Smaller parameter space model.
        joint_model_chain: [chain] Generalised chain with states from both models.
        symbols: [list] Strings to label plots with.
    &#34;&#34;&#34;

    # Fonts/visibility.
    #lr = 45 # label rotation
    n_ticks = 5 # tick labels
    n_m_ticks = 5

    axis_title_size = 16
    axis_tick_size = 10

    # Model sizing.
    N_dim = 6 #supset_model.D
    n_dim = 3 #subset_model.D

    style()
    figure = corner.corner(supset_states.T) # Use corner for layout/sizing.
    figure.subplots_adjust(wspace = 0, hspace = 0)

    # Fonts/visibility.
    # plt.rcParams[&#39;font.size&#39;] = 12
    # plt.rcParams[&#39;axes.titlesize&#39;] = 20
    # plt.rcParams[&#39;axes.labelsize&#39;] = 20

    # Extract axes.
    axes = np.array(figure.axes).reshape((N_dim, N_dim))

    #print(supset_surrogate.samples.numpy())
    single_theta, binary_theta, data = curves

    # Loop diagonal.
    for i in range(N_dim):
        ax = axes[i, i]

        ax.cla()

        nbins = 20

        if i &lt; 3:
            ax.hist(np.concatenate((surrogate_supset_states[i, :], surrogate_subset_states[i, :])), bins = nbins, density = True, color = &#39;tab:orange&#39;, alpha = 1.0, histtype=&#39;step&#39;, range=ranges[i])
            ax.hist(np.concatenate((supset_states[i, :], subset_states[i, :])), bins = nbins, density = True, color = &#39;tab:blue&#39;, alpha = 1.0, histtype=&#39;step&#39;, range=ranges[i])
            ax.axvline(single_theta.scaled[i+1], color=&#39;tab:green&#39;, ls=&#39;-&#39;, lw=1)

        else:
            ax.hist(surrogate_supset_states[i, :], bins = nbins, density = True, color = &#39;tab:orange&#39;, alpha = 1.0, histtype=&#39;step&#39;, range=ranges[i])
            ax.hist(supset_states[i, :], bins = nbins, density = True, color = &#39;tab:blue&#39;, alpha = 1.0, histtype=&#39;step&#39;, range=ranges[i])

        if event_params is not None:             
            ax.axvline(event_params.scaled[i+1], color = &#39;black&#39;, ls = &#39;-&#39;, lw = 2)
            ax.axvline(binary_theta.scaled[i+1], color=&#39;tab:purple&#39;, ls=&#39;-&#39;, lw=1)



        ax.set_xlim(ranges[i])

        ax.tick_params(which=&#39;both&#39;, top=False, direction=&#39;in&#39;)
        ax.minorticks_on()
        ax.yaxis.set_minor_locator(ticker.AutoMinorLocator(n_m_ticks))
        ax.xaxis.set_minor_locator(ticker.AutoMinorLocator(n_m_ticks))
        ax.tick_params(which=&#39;major&#39;, length=8)
        ax.tick_params(which=&#39;minor&#39;, length=4)
        ax.yaxis.set_major_locator(plt.MaxNLocator(n_ticks))
        ax.xaxis.set_major_locator(plt.MaxNLocator(n_ticks))

        if i == 0: # First diagonal tile.
            #ax.set_ylabel(symbols[i], fontsize = axis_title_size)
            #ax.tick_params(axis=&#39;y&#39;,  labelrotation = 45)
            ax.axes.get_xaxis().set_ticklabels([])
            ax.axes.get_yaxis().set_ticklabels([])
            ax.set_title(&#39;(a)&#39;, loc=&#39;left&#39;, fontsize=20)

        elif i == N_dim - 1: # Last diagonal tile.
            ax.set_xlabel(symbols[i], fontsize = axis_title_size)
            ax.axes.get_yaxis().set_ticklabels([])
            ax.tick_params(axis = &#39;x&#39;,  labelrotation = 45, labelsize = axis_tick_size)
            plt.setp(ax.xaxis.get_majorticklabels(), ha=&#34;right&#34;, rotation_mode=&#34;anchor&#34;)

        else:
            ax.axes.get_xaxis().set_ticklabels([])
            ax.axes.get_yaxis().set_ticklabels([])

        ax.axes.get_yaxis().set_ticks([])

        ax.axes.get_yaxis().set_ticklabels([])
        ax.axes.get_yaxis().set_ticks([])
        #ax.axes.get_xaxis().set_ticklabels([])
        #ax.axes.get_xaxis().set_ticks([])






    # Loop lower triangular.
    for yi in range(N_dim):
        for xi in range(yi):
            ax = axes[yi, xi]
            ax.cla()
            
            #if yi&lt;3 and xi&lt;3:
            #    ax.scatter(subset_states[xi, :], subset_states[yi, :], c = &#39;white&#39;, alpha = 0.0, marker = &#34;.&#34;, s = 75, linewidth = 0.0)
            #ax.scatter(supset_states[xi, :], supset_states[yi, :], c = np.linspace(0.0, 1.0, len(supset_states[yi, :])), cmap = plt.get_cmap(&#39;RdBu&#39;), alpha = 0.05, marker = &#34;o&#34;, s = 25, linewidth = 0.0)

            #xlim = ax.get_xlim()
            #ylim = ax.get_ylim()
            
            sns.kdeplot(x=surrogate_supset_states[xi, :], y=surrogate_supset_states[yi, :], ax=ax, levels=[0.393, 0.865, 0.989], color=&#39;tab:orange&#39;, bw_adjust=1.2, clip=[ranges[xi], ranges[yi]])
            sns.kdeplot(x=supset_states[xi, :], y=supset_states[yi, :], ax=ax, levels=[0.393, 0.865, 0.989], color=&#39;tab:blue&#39;, bw_adjust=1.2, clip=[ranges[xi], ranges[yi]])
            

            ax.scatter(event_params.scaled[xi+1], event_params.scaled[yi+1], color = &#39;black&#39;, alpha = 1.0, marker = &#34;D&#34;, s = 50, linewidth = 1, zorder=9)
            #ax.axvline(event_params.scaled[xi], color = &#39;black&#39;, ls = &#39;-&#39;, lw = 2)
            #ax.axhline(event_params.scaled[yi], color = &#39;black&#39;, ls = &#39;-&#39;, lw = 2)
            ax.scatter(binary_theta.scaled[xi+1], binary_theta.scaled[yi+1], color = &#39;tab:purple&#39;, alpha = 1.0, marker = &#34;8&#34;, s = 50, linewidth = 1, zorder=10)
            ax.set_xlim(ranges[xi])
            ax.set_ylim(ranges[yi])


            ax.tick_params(which=&#39;both&#39;, top=True, right=True, direction=&#39;in&#39;)
            ax.minorticks_on()
            ax.tick_params(which=&#39;major&#39;, length=8)
            ax.tick_params(which=&#39;minor&#39;, length=4)
            ax.yaxis.set_minor_locator(ticker.AutoMinorLocator(n_m_ticks))
            ax.xaxis.set_minor_locator(ticker.AutoMinorLocator(n_m_ticks))
            ax.yaxis.set_major_locator(plt.MaxNLocator(n_ticks))
            ax.xaxis.set_major_locator(plt.MaxNLocator(n_ticks))

            if yi == N_dim - 1: # Bottom row.
                ax.set_xlabel(symbols[xi], fontsize = axis_title_size)
                ax.tick_params(axis = &#39;x&#39;,  labelrotation = 45, labelsize = axis_tick_size)
                plt.setp(ax.xaxis.get_majorticklabels(), ha=&#34;right&#34;, rotation_mode=&#34;anchor&#34;)

            else:    
                ax.axes.get_xaxis().set_ticklabels([])

            if xi == 0: # First column.
                ax.set_ylabel(symbols[yi], fontsize = axis_title_size)
                ax.tick_params(axis = &#39;y&#39;,  labelrotation = 45, labelsize = axis_tick_size)
                plt.setp(ax.yaxis.get_majorticklabels(), va=&#34;bottom&#34;, rotation_mode=&#34;anchor&#34;)

            else:    
                ax.axes.get_yaxis().set_ticklabels([])



            # Add upper triangular plots.
            if xi &lt; n_dim and yi &lt; n_dim:
                
                # Acquire axes and plot.
                axs = figure.get_axes()[4].get_gridspec()
                axt = figure.add_subplot(axs[xi, yi])

                #axt.scatter(subset_states[yi, :], subset_states[xi, :], c = np.linspace(0.0, 1.0, len(subset_states[yi, :])), cmap = plt.get_cmap(&#39;RdBu&#39;), alpha = 0.05, marker = &#34;o&#34;, s = 25, linewidth = 0.0)
                
                sns.kdeplot(x=surrogate_subset_states[yi, :], y=surrogate_subset_states[xi, :], ax=axt, levels=[0.393, 0.865, 0.989], color=&#39;tab:orange&#39;, bw_adjust=1.2, clip=[ranges[yi], ranges[xi]])
                sns.kdeplot(x=subset_states[yi, :], y=subset_states[xi, :], ax=axt, levels=[0.393, 0.865, 0.989], color=&#39;tab:blue&#39;, bw_adjust=1.2, clip=[ranges[yi], ranges[xi]])

                axt.scatter(x=single_theta.scaled[yi+1], y=single_theta.scaled[xi+1], color = &#39;tab:green&#39;, alpha = 1.0, marker = &#34;8&#34;, s = 50, linewidth = 1, zorder=9)

                axt.set_xlim(ranges[yi])
                axt.set_ylim(ranges[xi])

                axt.tick_params(which=&#39;both&#39;, top=True, right=True, direction=&#39;in&#39;)
                axt.minorticks_on()
                axt.yaxis.set_minor_locator(ticker.AutoMinorLocator(n_m_ticks))
                axt.xaxis.set_minor_locator(ticker.AutoMinorLocator(n_m_ticks))
                axt.tick_params(which=&#39;major&#39;, length=8)
                axt.tick_params(which=&#39;minor&#39;, length=4)
                axt.yaxis.set_major_locator(plt.MaxNLocator(n_ticks))
                axt.xaxis.set_major_locator(plt.MaxNLocator(n_ticks))

                if yi == n_dim - 1: # Last column.
                    axt.set_ylabel(symbols[xi], fontsize = axis_title_size)
                    axt.yaxis.tick_right()
                    axt.tick_params(which=&#39;both&#39;, bottom=True, left=True, labelsize = axis_tick_size)
                    axt.yaxis.set_label_position(&#34;right&#34;)
                    axt.tick_params(axis = &#39;y&#39;,  labelrotation = 45, labelsize = axis_tick_size)
                    plt.setp(axt.yaxis.get_majorticklabels(), va=&#34;top&#34;, rotation_mode=&#34;anchor&#34;)
                
                else:
                    axt.axes.get_yaxis().set_ticklabels([])
                
                if xi == 0: # First row.
                    axt.set_xlabel(symbols[yi], fontsize = axis_title_size)
                    axt.tick_params(axis = &#39;x&#39;,  labelrotation = 45, labelsize = axis_tick_size)
                    axt.xaxis.tick_top()
                    axt.tick_params(which=&#39;both&#39;, bottom=True, left=True, labelsize = axis_tick_size)
                    axt.xaxis.set_label_position(&#34;top&#34;)
                    plt.setp(axt.xaxis.get_majorticklabels(), ha=&#34;left&#34;, rotation_mode=&#34;anchor&#34;)
                
                else:
                    axt.axes.get_xaxis().set_ticklabels([])



    figure.savefig(&#39;results/&#39; + name + &#39;-broccoli.png&#39;, bbox_inches = &#34;tight&#34;, dpi = dpi, transparent=True)
    figure.clf()

    return</code></pre>
</details>
</dd>
<dt id="bayesian-microlensing.plotting.fitted_flux"><code class="name flex">
<span>def <span class="ident">fitted_flux</span></span>(<span>m, theta, data, ts, label=None, color=None, alpha=None, ls=None, lw=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the flux produced by fitted microlensing parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>m</code></strong></dt>
<dd>[int] Model index.</dd>
<dt><strong><code>theta</code></strong></dt>
<dd>[state] Model parameters.</dd>
<dt><strong><code>ts</code></strong></dt>
<dd>[list] Range to plot over.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fitted_flux(m, theta, data, ts, label = None, color = None, alpha = None, ls = None, lw = None):
    &#34;&#34;&#34;Plot the flux produced by fitted microlensing parameters.

    Args:
        m: [int] Model index.
        theta: [state] Model parameters.
        ts: [list] Range to plot over.
    &#34;&#34;&#34;
    if m == 0:
        model = mm.Model(dict(zip([&#39;t_0&#39;, &#39;u_0&#39;, &#39;t_E&#39;], theta.truth[1:])))
    if m == 1:
        model = mm.Model(dict(zip([&#39;t_0&#39;, &#39;u_0&#39;, &#39;t_E&#39;, &#39;q&#39;, &#39;s&#39;, &#39;alpha&#39;], theta.truth[1:])))
    model.set_magnification_methods([ts[0], &#39;point_source&#39;, ts[1]])

    epochs = np.linspace(ts[0], ts[1], 720)

    a = model.magnification(epochs)
    # Fit proposed flux as least squares solution.
    #F = light_curve_simulation.least_squares_signal(a, data.flux)
    F = (a-1)*theta.truth[0]+1
    plt.plot(epochs, F, color = color, label = label, alpha = alpha, ls = ls, lw = lw)

    return</code></pre>
</details>
</dd>
<dt id="bayesian-microlensing.plotting.flux"><code class="name flex">
<span>def <span class="ident">flux</span></span>(<span>m, theta, ts, caustics=None, label=None, color=None, alpha=None, ls=None, lw=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the magnification produced by a microlensing event.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>m</code></strong></dt>
<dd>[int] Model index.</dd>
<dt><strong><code>theta</code></strong></dt>
<dd>[state] Model parameters.</dd>
<dt><strong><code>ts</code></strong></dt>
<dd>[list] Range to plot over.</dd>
<dt><strong><code>caustics</code></strong></dt>
<dd>[optional, bool] Whether the plot should be of the caustic curves.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flux(m, theta, ts, caustics = None, label = None, color = None, alpha = None, ls = None, lw = None):
    &#34;&#34;&#34;Plot the magnification produced by a microlensing event.

    Args:
        m: [int] Model index.
        theta: [state] Model parameters.
        ts: [list] Range to plot over.
        caustics: [optional, bool] Whether the plot should be of the caustic curves.
    &#34;&#34;&#34;
    if m == 0:
        model = mm.Model(dict(zip([&#39;t_0&#39;, &#39;u_0&#39;, &#39;t_E&#39;], theta.truth[1:])))
    if m == 1:
        model = mm.Model(dict(zip([&#39;t_0&#39;, &#39;u_0&#39;, &#39;t_E&#39;, &#39;q&#39;, &#39;s&#39;, &#39;alpha&#39;], theta.truth[1:])))
    model.set_magnification_methods([ts[0], &#39;point_source&#39;, ts[1]])

    epochs = np.linspace(ts[0], ts[1], 720)

    if caustics is not None:
        if caustics &gt; 0:
            model.plot_trajectory(t_start = ts[0], t_stop = ts[1], color = &#39;black&#39;, linewidth = 1, ls=&#39;-&#39;, alpha = alpha, arrow = False)
        model.plot_caustics(color = color, s = 0.25, marker = &#39;o&#39;, n_points = 25000, label = label)

    else:
        A = (model.magnification(epochs)-1)*theta.truth[0]+1
        plt.plot(epochs, A, color = color, label = label, alpha = alpha, ls = ls, lw = lw)

    return</code></pre>
</details>
</dd>
<dt id="bayesian-microlensing.plotting.style"><code class="name flex">
<span>def <span class="ident">style</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def style():
    plt.rcParams[&#34;font.family&#34;] = &#34;sans-serif&#34;
    plt.rcParams[&#39;font.size&#39;] = 15 #12
    plt.style.use(&#39;seaborn-bright&#39;)
    plt.rcParams[&#34;legend.edgecolor&#34;] = &#39;0&#39;
    plt.rcParams[&#34;legend.framealpha&#34;] = 1
    plt.rcParams[&#34;legend.title_fontsize&#34;] = 10
    plt.rcParams[&#34;legend.fontsize&#34;] = 9
    plt.rcParams[&#34;grid.linestyle&#34;] = &#39;dashed&#39; 
    plt.rcParams[&#34;grid.alpha&#34;] = 0.25
    plt.rc(&#39;axes.formatter&#39;, useoffset=False)
    return</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bayesian-microlensing" href="index.html">bayesian-microlensing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="bayesian-microlensing.plotting.broccoli" href="#bayesian-microlensing.plotting.broccoli">broccoli</a></code></li>
<li><code><a title="bayesian-microlensing.plotting.fitted_flux" href="#bayesian-microlensing.plotting.fitted_flux">fitted_flux</a></code></li>
<li><code><a title="bayesian-microlensing.plotting.flux" href="#bayesian-microlensing.plotting.flux">flux</a></code></li>
<li><code><a title="bayesian-microlensing.plotting.style" href="#bayesian-microlensing.plotting.style">style</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>